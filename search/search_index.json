{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#agent-client-protocol-sdk-python","title":"Agent Client Protocol SDK (Python)","text":"<p>Welcome to the Python SDK for the Agent Client Protocol (ACP). The package ships ready-to-use transports, typed protocol models, and examples that stream messages to ACP-aware clients such as Zed.</p>"},{"location":"#what-you-get","title":"What you get","text":"<ul> <li>Pydantic models generated from the upstream ACP schema (<code>acp.schema</code>)</li> <li>Async agent/client wrappers with JSON-RPC task supervision built in</li> <li>Process helpers (<code>spawn_agent_process</code>, <code>spawn_client_process</code>) for embedding ACP nodes inside Python applications</li> <li>Helper APIs in <code>acp.helpers</code> that mirror the Go/TS SDK builders for content blocks, tool calls, and session updates. They instantiate the generated Pydantic types for you, so call sites stay concise without sacrificing validation.</li> <li>Examples that showcase streaming updates, file operations, permission flows, and even a Gemini CLI bridge (<code>examples/gemini.py</code>)</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":"<ol> <li>Install the package:    <code>bash    pip install agent-client-protocol</code></li> <li>Launch the provided echo agent to verify your setup:    <code>bash    python examples/echo_agent.py</code></li> <li>Point your ACP-capable client at the running process (for Zed, configure an Agent Server entry). The SDK takes care of JSON-RPC framing and lifecycle transitions.</li> </ol> <p>Prefer a guided tour? Head to the Quickstart for terminal, editor, and programmatic launch walkthroughs.</p>"},{"location":"#gemini-cli-bridge","title":"Gemini CLI bridge","text":"<p>If you have access to the Gemini CLI (<code>gemini --experimental-acp</code>), run:</p> <pre><code>python examples/gemini.py --yolo\n</code></pre> <p>Flags mirror the Go SDK example:</p> <ul> <li><code>--gemini /path/to/cli</code> or <code>ACP_GEMINI_BIN</code> to override discovery</li> <li><code>--model</code>, <code>--sandbox</code>, <code>--debug</code> forwarded verbatim</li> <li><code>--yolo</code> auto-approves permission prompts with sensible defaults</li> </ul> <p>An opt-in smoke test lives at <code>tests/test_gemini_example.py</code>. Enable it with <code>ACP_ENABLE_GEMINI_TESTS=1</code> (and optionally <code>ACP_GEMINI_TEST_ARGS</code>) when the CLI is authenticated; otherwise the test stays skipped.</p>"},{"location":"#documentation-map","title":"Documentation map","text":"<ul> <li>Quickstart: install, run, and embed the echo agent, plus next steps for extending it</li> <li>Releasing: schema upgrade workflow, version bumps, and publishing checklist</li> </ul> <p>Source code lives under <code>src/acp/</code>, while tests and additional examples are available in <code>tests/</code> and <code>examples/</code>. If you plan to contribute, see the repository README for the development workflow.</p>"},{"location":"contrib/","title":"Experimental Contrib Modules","text":"<p>The helpers under <code>acp.contrib</code> capture patterns we observed in reference integrations such as Toad and kimi-cli. Every API here is experimental and may change without notice.</p>"},{"location":"contrib/#sessionaccumulator","title":"SessionAccumulator","text":"<p>Module: <code>acp.contrib.session_state</code></p> <p>UI surfaces like Toad need a live, merged view of the latest tool calls, plan entries, and message stream. The core SDK only emits raw <code>SessionNotification</code> payloads, so applications usually end up writing their own state layer. <code>SessionAccumulator</code> offers that cache out of the box.</p> <p>Capabilities:</p> <ul> <li><code>SessionAccumulator.apply(notification)</code> merges <code>tool_call</code> and <code>tool_call_update</code> events, backfilling a missing start message when necessary.</li> <li>Each call to <code>snapshot()</code> returns an immutable <code>SessionSnapshot</code> (Pydantic model) containing the active plan, current mode ID, available commands, and historical user/agent/thought chunks.</li> <li><code>subscribe(callback)</code> wires a lightweight observer that receives every new snapshot, making it easy to refresh UI widgets.</li> <li>Automatic reset when a different session ID arrives (configurable via <code>auto_reset_on_session_change</code>).</li> </ul> <p>Integration tip: create one accumulator per UI controller. Feed every <code>SessionNotification</code> through it, then render from <code>snapshot.tool_calls</code> or <code>snapshot.user_messages</code> instead of mutating state manually.</p>"},{"location":"contrib/#toolcalltracker-permissionbroker","title":"ToolCallTracker &amp; PermissionBroker","text":"<p>Modules: <code>acp.contrib.tool_calls</code> and <code>acp.contrib.permissions</code></p> <p>Agent-side runtimes (for example kimi-cli) are responsible for synthesising tool call IDs, streaming argument fragments, and formatting permission prompts. Managing bare Pydantic models quickly devolves into boilerplate; these helpers centralise the bookkeeping.</p> <ul> <li><code>ToolCallTracker.start()/progress()/append_stream_text()</code> manages tool call state and emits canonical <code>ToolCallStart</code> / <code>ToolCallProgress</code> messages. The tracker also exposes <code>view()</code> (immutable <code>TrackedToolCallView</code>) and <code>tool_call_model()</code> for logging or permission prompts.</li> <li><code>PermissionBroker.request_for()</code> wraps <code>requestPermission</code> RPCs. It reuses the tracker\u2019s state (or an explicit <code>ToolCall</code>), applies optional extra content, and defaults to a standard Approve / Approve for session / Reject option set.</li> <li><code>default_permission_options()</code> exposes that canonical option triple so applications can customise or extend it.</li> </ul> <p>Integration tip: keep a single tracker alongside your agent loop. Emit tool call notifications through it, and hand the tracker to <code>PermissionBroker</code> so permission prompts stay in sync with the latest call state.</p>"},{"location":"contrib/#design-guardrails","title":"Design Guardrails","text":"<p>To stay aligned with the ACP schema, the contrib layer follows a few rules:</p> <ul> <li>Protocol types continue to live in <code>acp.schema</code>. Contrib code always copies them via <code>.model_copy(deep=True)</code> to avoid mutating shared instances.</li> <li>Helpers are opt-in; the core package never imports them implicitly and imposes no UI or agent framework assumptions.</li> <li>Implementations focus on the common pain points (tool call aggregation, permission requests) while leaving business-specific policy to the application.</li> </ul> <p>Try the contrib modules in your agent or client, and open an issue/PR with feedback so we can decide which pieces should graduate into the stable surface.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This guide gets you from a clean environment to streaming ACP messages from a Python agent.</p>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10-3.14 and either <code>pip</code> or <code>uv</code></li> <li>An ACP-capable client such as Zed (optional but recommended for testing)</li> </ul>"},{"location":"quickstart/#1-install-the-sdk","title":"1. Install the SDK","text":"<pre><code>pip install agent-client-protocol\n# or\nuv add agent-client-protocol\n</code></pre>"},{"location":"quickstart/#2-launch-the-echo-agent-terminal","title":"2. Launch the Echo agent (terminal)","text":"<p>Start the ready-made echo example \u2014 it streams text blocks back to any ACP client:</p> <pre><code>python examples/echo_agent.py\n</code></pre> <p>Leave this process running while you connect from an editor or another program.</p>"},{"location":"quickstart/#3-connect-from-an-editor","title":"3. Connect from an editor","text":""},{"location":"quickstart/#zed","title":"Zed","text":"<p>Add an Agent Server entry in <code>settings.json</code> (Zed \u2192 Settings \u2192 Agents panel):</p> <pre><code>{\n  \"agent_servers\": {\n    \"Echo Agent (Python)\": {\n      \"command\": \"/abs/path/to/python\",\n      \"args\": [\n        \"/abs/path/to/agentclientprotocol/python-sdk/examples/echo_agent.py\"\n      ]\n    }\n  }\n}\n</code></pre> <p>Open the Agents panel and start the session. Each message you send should be echoed back via streamed <code>session/update</code> notifications.</p>"},{"location":"quickstart/#other-clients","title":"Other clients","text":"<p>Any ACP client that communicates over stdio can spawn the same script; no additional transport configuration is required.</p>"},{"location":"quickstart/#programmatic-launch","title":"Programmatic launch","text":"<pre><code>import asyncio\nimport sys\nfrom pathlib import Path\n\nfrom acp import spawn_agent_process, text_block\nfrom acp.interfaces import Client\nfrom acp.schema import InitializeRequest, NewSessionRequest, PromptRequest, SessionNotification\n\n\nclass SimpleClient(Client):\n    async def requestPermission(self, params):  # pragma: no cover - minimal stub\n        return {\"outcome\": {\"outcome\": \"cancelled\"}}\n\n    async def sessionUpdate(self, params: SessionNotification) -&gt; None:\n        print(\"update:\", params.sessionId, params.update)\n\n\nasync def main() -&gt; None:\n    script = Path(\"examples/echo_agent.py\")\n    async with spawn_agent_process(lambda _agent: SimpleClient(), sys.executable, str(script)) as (conn, _proc):\n        await conn.initialize(InitializeRequest(protocolVersion=1))\n        session = await conn.newSession(NewSessionRequest(cwd=str(script.parent), mcpServers=[]))\n        await conn.prompt(\n            PromptRequest(\n                sessionId=session.sessionId,\n                prompt=[text_block(\"Hello from spawn!\")],\n            )\n        )\n\nasyncio.run(main())\n</code></pre> <p><code>spawn_agent_process</code> manages the child process, wires its stdio into ACP framing, and closes everything when the block exits. The mirror helper <code>spawn_client_process</code> lets you drive an ACP client from Python as well.</p>"},{"location":"quickstart/#4-extend-the-agent","title":"4. Extend the agent","text":"<p>Create your own agent by subclassing <code>acp.Agent</code>. The pattern mirrors the echo example:</p> <pre><code>from acp import Agent, PromptRequest, PromptResponse\n\n\nclass MyAgent(Agent):\n    async def prompt(self, params: PromptRequest) -&gt; PromptResponse:\n        # inspect params.prompt, stream updates, then finish the turn\n        return PromptResponse(stopReason=\"end_turn\")\n</code></pre> <p>Hook it up with <code>AgentSideConnection</code> inside an async entrypoint and wire it to your client. Refer to:</p> <ul> <li><code>examples/echo_agent.py</code> for the smallest streaming agent</li> <li><code>examples/agent.py</code> for an implementation that negotiates capabilities and streams richer updates</li> <li><code>examples/duet.py</code> to see <code>spawn_agent_process</code> in action alongside the interactive client</li> <li><code>examples/gemini.py</code> to drive the Gemini CLI (<code>--experimental-acp</code>) directly from Python</li> </ul> <p>Need builders for common payloads? <code>acp.helpers</code> mirrors the Go/TS helper APIs:</p> <pre><code>from acp import start_tool_call, update_tool_call, text_block, tool_content\n\nstart_update = start_tool_call(\"call-42\", \"Open file\", kind=\"read\", status=\"pending\")\nfinish_update = update_tool_call(\n    \"call-42\",\n    status=\"completed\",\n    content=[tool_content(text_block(\"File opened.\"))],\n)\n</code></pre> <p>Each helper wraps the generated Pydantic models in <code>acp.schema</code>, so the right discriminator fields (<code>type</code>, <code>sessionUpdate</code>, and friends) are always populated. That keeps examples readable while maintaining the same validation guarantees as constructing the models directly. Golden fixtures in <code>tests/test_golden.py</code> ensure the helpers stay in sync with future schema revisions.</p>"},{"location":"quickstart/#5-optional-talk-to-the-gemini-cli","title":"5. Optional: Talk to the Gemini CLI","text":"<p>If you have the Gemini CLI installed and authenticated:</p> <pre><code>python examples/gemini.py --yolo                # auto-approve permission prompts\npython examples/gemini.py --sandbox --model gemini-1.5-pro\n</code></pre> <p>Environment helpers:</p> <ul> <li><code>ACP_GEMINI_BIN</code> \u2014 override the CLI path (defaults to <code>PATH</code> lookup)</li> <li><code>ACP_GEMINI_TEST_ARGS</code> \u2014 extra flags forwarded during the smoke test</li> <li><code>ACP_ENABLE_GEMINI_TESTS=1</code> \u2014 opt-in toggle for <code>tests/test_gemini_example.py</code></li> </ul> <p>Authentication hiccups (e.g. missing <code>GOOGLE_CLOUD_PROJECT</code>) are surfaced but treated as skips during testing so the suite stays green on machines without credentials.</p>"},{"location":"releasing/","title":"Releasing","text":"<p>This project tracks the ACP schema tags published by <code>agentclientprotocol/agent-client-protocol</code>. Every release should line up with one of those tags so that the generated <code>acp.schema</code> module, examples, and package version remain consistent.</p>"},{"location":"releasing/#preparation","title":"Preparation","text":"<p>Pick the target schema tag (for example <code>v0.4.5</code>) and regenerate the protocol bindings:</p> <pre><code>ACP_SCHEMA_VERSION=v0.4.5 make gen-all\n</code></pre> <p>This downloads the upstream schema package and rewrites <code>schema/</code> plus the generated <code>src/acp/schema.py</code>.</p> <p>Bump the project version in <code>pyproject.toml</code>, updating <code>uv.lock</code> if dependencies changed.</p> <p>Run the standard checks:</p> <pre><code>make check\nmake test\n</code></pre> <ul> <li><code>make check</code> covers Ruff formatting/linting, static analysis, and dependency hygiene.</li> <li><code>make test</code> executes pytest (including doctests).</li> </ul> <p>Refresh documentation and examples (for instance the Gemini walkthrough) so they match the new schema behaviour.</p>"},{"location":"releasing/#commit-merge","title":"Commit &amp; Merge","text":"<ol> <li>Make sure the diff only includes the expected artifacts: regenerated schema sources, <code>src/acp/schema.py</code>, version bumps, and doc updates.</li> <li>Commit with a Conventional Commit message (for example <code>release: v0.4.5</code>) and note in the PR:</li> <li>The ACP schema tag you targeted</li> <li>Results from <code>make check</code> / <code>make test</code></li> <li>Any behavioural or API changes worth highlighting</li> <li>Merge once the review is approved.</li> </ol>"},{"location":"releasing/#publish-via-github-release","title":"Publish via GitHub Release","text":"<p>Publishing is automated through <code>on-release-main.yml</code>. After the release PR merges to <code>main</code>:</p> <ol> <li>Draft a GitHub Release for the new tag (e.g. <code>v0.4.5</code>). If the tag is missing, the release UI will create it.</li> <li>Once published, the workflow will:</li> <li>Write the tag back into <code>pyproject.toml</code> to keep the package version aligned</li> <li>Build and publish to PyPI via <code>uv publish</code> (using the <code>PYPI_TOKEN</code> secret)</li> <li>Deploy updated documentation with <code>mkdocs gh-deploy</code></li> </ol> <p>No local <code>uv build</code>/<code>uv publish</code> runs are required\u2014focus on providing a complete release summary (highlights, compatibility notes, etc.).</p>"},{"location":"releasing/#additional-notes","title":"Additional Notes","text":"<ul> <li>Breaking schema updates often require refreshing golden fixtures (<code>tests/test_golden.py</code>), end-to-end cases such as <code>tests/test_rpc.py</code>, and any affected examples.</li> <li>Use <code>make clean</code> to remove generated artifacts if you need a fresh baseline before re-running <code>make gen-all</code>.</li> <li>Run optional checks like the Gemini smoke test (<code>ACP_ENABLE_GEMINI_TESTS=1</code>) whenever the environment is available to catch regressions before publishing.</li> </ul>"}]}