{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#agent-client-protocol-sdk-python","title":"Agent Client Protocol SDK (Python)","text":"<p>Ship ACP-compatible agents and clients in Python without rebuilding JSON-RPC transports or schema models. This SDK mirrors each ACP release so your integrations stay interoperable with editors, CLIs, and hosted clients.</p>"},{"location":"#install-verify","title":"Install &amp; verify","text":"<pre><code>pip install agent-client-protocol\n# or\nuv add agent-client-protocol\n</code></pre> <p>Next steps live in the Quickstart: launch the echo agent, wire it to Zed (or another ACP client), and exercise the programmatic spawn helpers.</p>"},{"location":"#acp-at-a-glance","title":"ACP at a glance","text":"<ul> <li>ACP is the stdio protocol that lets \u201cclients\u201d (editors, shells, CLIs) orchestrate AI \u201cagents.\u201d</li> <li>Sessions exchange structured payloads (<code>session/update</code>, permission prompts, tool calls) defined in the upstream schema.</li> <li>Matching the schema version keeps your Python integrations compatible with tools such as Zed, Gemini CLI, or kimi-cli.</li> </ul>"},{"location":"#sdk-building-blocks","title":"SDK building blocks","text":"<ul> <li><code>acp.schema</code>: generated Pydantic models that validate every payload against the canonical specification.</li> <li><code>acp.agent</code> / <code>acp.client</code>: async base classes, JSON-RPC supervision, and lifecycle orchestration.</li> <li><code>acp.helpers</code>: builders for content blocks, tool calls, permissions, and notifications.</li> <li><code>acp.contrib</code>: experimental utilities (session accumulators, permission brokers, tool call trackers) harvested from production deployments.</li> <li><code>examples/</code>: runnable agents, clients, duet demos, and the Gemini CLI bridge.</li> </ul>"},{"location":"#quick-links","title":"Quick links","text":"Need Link Quickstart walkthrough quickstart.md Real-world adopters use-cases.md Contrib helpers contrib.md Releasing workflow releasing.md Example scripts github.com/agentclientprotocol/python-sdk/tree/main/examples"},{"location":"#choose-a-path","title":"Choose a path","text":"<ul> <li>Just exploring? Skim use-cases.md to see how kimi-cli, agent-client-kernel, and others use the SDK.</li> <li>Building agents? Copy <code>examples/echo_agent.py</code> or <code>examples/agent.py</code>, then layer in <code>acp.helpers</code> for tool calls and permissions.</li> <li>Embedding clients? Start with <code>examples/client.py</code> or the <code>spawn_agent_process</code> / <code>spawn_client_process</code> helpers in the Quickstart.</li> </ul>"},{"location":"#reference-material","title":"Reference material","text":"<ul> <li>Quickstart \u2014 installation, editor wiring, and programmatic launch walkthroughs.</li> <li>Use Cases \u2014 real adopters with succinct descriptions of what they build.</li> <li>Experimental Contrib \u2014 deep dives on the <code>acp.contrib</code> utilities.</li> <li>Releasing \u2014 schema upgrade process, versioning policy, and publishing checklist.</li> </ul> <p>Need API-level details? Browse the source in <code>src/acp/</code> or generate docs with <code>mkdocstrings</code>.</p>"},{"location":"#feedback-support","title":"Feedback &amp; support","text":"<ul> <li>Open issues or discussions on GitHub for bugs, feature requests, or integration help.</li> <li>Join GitHub Discussions to swap ideas.</li> <li>Chat with the community on agentclientprotocol.zulipchat.com.</li> <li>Follow ACP roadmap updates at agentclientprotocol.com.</li> </ul>"},{"location":"contrib/","title":"Experimental Contrib Modules","text":"<p>The helpers under <code>acp.contrib</code> package recurring patterns we saw in integrations such as Toad, kimi-cli, and Gemini. Keep in mind they are experimental\u2014APIs can still shift as we learn. Use this page as a menu:</p> <ul> <li><code>session_state.SessionAccumulator</code> \u2014 build a canonical, immutable snapshot of every session update so UIs can render tool calls and plans without re-implementing state machines.</li> <li><code>tool_calls.ToolCallTracker</code> + <code>permissions.PermissionBroker</code> \u2014 coordinate streamed tool call updates and permission prompts from one place.</li> </ul>"},{"location":"contrib/#sessionaccumulator-acpcontribsession_state","title":"SessionAccumulator (<code>acp.contrib.session_state</code>)","text":"<p>Use it when: you need a live, merged view of <code>SessionNotification</code> events (e.g. tool calls, plan entries, user/agent messages) to drive UI widgets.</p> <p>Key capabilities</p> <ul> <li><code>SessionAccumulator.apply(notification)</code> reconciles <code>tool_call</code> and <code>tool_call_update</code> payloads, even if the start event arrives late.</li> <li><code>snapshot()</code> returns an immutable <code>SessionSnapshot</code> Pydantic model containing the plan, current mode, commands, and ordered message history.</li> <li><code>subscribe(callback)</code> lets you push snapshots into stores or UI components whenever state changes.</li> <li>Automatic reset on session-change (toggle with <code>auto_reset_on_session_change</code>).</li> </ul> <p>Tip: Create one accumulator per UI controller. Feed every raw <code>SessionNotification</code> into it and render from <code>snapshot.tool_calls</code> / <code>snapshot.user_messages</code> instead of mutating state manually.</p>"},{"location":"contrib/#toolcalltracker-permissionbroker-acpcontribtool_calls-acpcontribpermissions","title":"ToolCallTracker &amp; PermissionBroker (<code>acp.contrib.tool_calls</code>, <code>acp.contrib.permissions</code>)","text":"<p>Use them when: your agent runtime synthesises tool call IDs, streams arguments, and prompts the user for approval. The helpers centralise the bookkeeping so you don\u2019t juggle raw Pydantic models.</p> <ul> <li><code>ToolCallTracker.start()/progress()/append_stream_text()</code> emits canonical <code>ToolCallStart</code> / <code>ToolCallProgress</code> updates and keeps an in-memory view via <code>view()</code> or <code>tool_call_model()</code>.</li> <li><code>PermissionBroker.request_for()</code> wraps <code>requestPermission</code> RPCs. It reuses tracker state (or a provided <code>ToolCall</code>), lets you append extra content, and defaults to Approve / Approve for session / Reject options.</li> <li><code>default_permission_options()</code> exposes that canonical option triple if you need to customise it.</li> </ul> <p>Tip: Keep one tracker near the agent event loop. Emit notifications through it and share the tracker with <code>PermissionBroker</code> so permission prompts always match the latest tool call state.</p>"},{"location":"contrib/#design-guardrails","title":"Design Guardrails","text":"<p>To stay aligned with the ACP schema, the contrib layer follows a few rules:</p> <ul> <li>Schema data classes continue to live in <code>acp.schema</code>. Contrib helpers clone them with <code>.model_copy(deep=True)</code> before mutation.</li> <li>The core runtime never imports contrib modules implicitly\u2014you opt in when they help.</li> <li>Helpers focus on painful bookkeeping (tool call aggregation, permission UX) and leave product-specific policy to your application.</li> </ul> <p>Try the contrib modules, then open an issue or PR with feedback so we know which APIs should graduate into the stable surface.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Spin up a working ACP agent/client loop in minutes. Keep this page beside the terminal and check off each section as you go. Want inspiration? Hop to the Use Cases list to see how teams like kimi-cli or Zed apply the SDK in production.</p>"},{"location":"quickstart/#quick-checklist","title":"Quick checklist","text":"Goal Command / Link Install the SDK <code>pip install agent-client-protocol</code> or <code>uv add agent-client-protocol</code> Run the echo agent <code>python examples/echo_agent.py</code> Point Zed (or another client) at it Update <code>settings.json</code> as shown below Programmatically drive an agent Copy the <code>spawn_agent_process</code> example Run tests before hacking further <code>make check &amp;&amp; make test</code>"},{"location":"quickstart/#before-you-begin","title":"Before you begin","text":"<ul> <li>Python 3.10\u20133.14 with <code>pip</code> or <code>uv</code></li> <li>An ACP-capable client such as Zed (recommended for validation)</li> <li>Optional: the Gemini CLI (<code>gemini --experimental-acp</code>) for the bridge example</li> </ul>"},{"location":"quickstart/#step-1-install-the-sdk","title":"Step 1 \u2014 Install the SDK","text":"<p>Install the library from PyPI or add it to your uv workspace.</p> <pre><code>pip install agent-client-protocol\n# or\nuv add agent-client-protocol\n</code></pre>"},{"location":"quickstart/#step-2-launch-the-echo-agent","title":"Step 2 \u2014 Launch the Echo agent","text":"<p>Run the provided streaming agent so clients have something to talk to.</p> <p>Start the ready-made echo example; it streams text blocks back to any ACP client. Leave it running in a terminal:</p> <pre><code>python examples/echo_agent.py\n</code></pre>"},{"location":"quickstart/#step-3-connect-from-an-acp-aware-client","title":"Step 3 \u2014 Connect from an ACP-aware client","text":"<p>Point a client at the script and confirm you can exchange streamed updates.</p>"},{"location":"quickstart/#zed","title":"Zed","text":"<p>Add an Agent Server entry in <code>settings.json</code> (Zed \u2192 Settings \u2192 Agents panel):</p> <pre><code>{\n  \"agent_servers\": {\n    \"Echo Agent (Python)\": {\n      \"command\": \"/abs/path/to/python\",\n      \"args\": [\n        \"/abs/path/to/agentclientprotocol/python-sdk/examples/echo_agent.py\"\n      ]\n    }\n  }\n}\n</code></pre> <p>Open the Agents panel and start the session. Each message you send should be echoed back via streamed <code>session/update</code> notifications.</p>"},{"location":"quickstart/#other-clients","title":"Other clients","text":"<p>Any ACP client that communicates over stdio can spawn the same script; no additional transport configuration is required.</p>"},{"location":"quickstart/#programmatic-launch","title":"Programmatic launch","text":"<p>Prefer to drive agents directly from Python? The <code>spawn_agent_process</code> helper wires stdio and lifecycle management for you:</p> <pre><code>import asyncio\nimport sys\nfrom pathlib import Path\n\nfrom acp import spawn_agent_process, text_block\nfrom acp.interfaces import Client\nfrom acp.schema import InitializeRequest, NewSessionRequest, PromptRequest, SessionNotification\n\n\nclass SimpleClient(Client):\n    async def requestPermission(self, params):  # pragma: no cover - minimal stub\n        return {\"outcome\": {\"outcome\": \"cancelled\"}}\n\n    async def sessionUpdate(self, params: SessionNotification) -&gt; None:\n        print(\"update:\", params.sessionId, params.update)\n\n\nasync def main() -&gt; None:\n    script = Path(\"examples/echo_agent.py\")\n    async with spawn_agent_process(lambda _agent: SimpleClient(), sys.executable, str(script)) as (conn, _proc):\n        await conn.initialize(InitializeRequest(protocolVersion=1))\n        session = await conn.newSession(NewSessionRequest(cwd=str(script.parent), mcpServers=[]))\n        await conn.prompt(\n            PromptRequest(\n                sessionId=session.sessionId,\n                prompt=[text_block(\"Hello from spawn!\")],\n            )\n        )\n\nasyncio.run(main())\n</code></pre> <p><code>spawn_agent_process</code> manages the child process, wires its stdio into ACP framing, and closes everything when the block exits. The mirror helper <code>spawn_client_process</code> lets you drive an ACP client from Python as well.</p>"},{"location":"quickstart/#step-4-extend-the-agent","title":"Step 4 \u2014 Extend the agent","text":"<p>Swap the echo demo for your own <code>Agent</code> subclass.</p> <p>Create your own agent by subclassing <code>acp.Agent</code>. The pattern mirrors the echo example:</p> <pre><code>from acp import Agent, PromptRequest, PromptResponse\n\n\nclass MyAgent(Agent):\n    async def prompt(self, params: PromptRequest) -&gt; PromptResponse:\n        # inspect params.prompt, stream updates, then finish the turn\n        return PromptResponse(stopReason=\"end_turn\")\n</code></pre> <p>Hook it up with <code>AgentSideConnection</code> inside an async entrypoint and wire it to your client. Refer to:</p> <ul> <li><code>examples/echo_agent.py</code> for the smallest streaming agent</li> <li><code>examples/agent.py</code> for an implementation that negotiates capabilities and streams richer updates</li> <li><code>examples/duet.py</code> to see <code>spawn_agent_process</code> in action alongside the interactive client</li> <li><code>examples/gemini.py</code> to drive the Gemini CLI (<code>--experimental-acp</code>) directly from Python</li> </ul> <p>Need builders for common payloads? <code>acp.helpers</code> mirrors the Go/TS helper APIs:</p> <pre><code>from acp import start_tool_call, update_tool_call, text_block, tool_content\n\nstart_update = start_tool_call(\"call-42\", \"Open file\", kind=\"read\", status=\"pending\")\nfinish_update = update_tool_call(\n    \"call-42\",\n    status=\"completed\",\n    content=[tool_content(text_block(\"File opened.\"))],\n)\n</code></pre> <p>Each helper wraps the generated Pydantic models in <code>acp.schema</code>, so the right discriminator fields (<code>type</code>, <code>sessionUpdate</code>, and friends) are always populated. That keeps examples readable while maintaining the same validation guarantees as constructing the models directly. Golden fixtures in <code>tests/test_golden.py</code> ensure the helpers stay in sync with future schema revisions.</p>"},{"location":"quickstart/#optional-talk-to-the-gemini-cli","title":"Optional \u2014 Talk to the Gemini CLI","text":"<p>Have the Gemini CLI installed? Run the bridge to exercise permission flows.</p> <p>If you have the Gemini CLI installed and authenticated:</p> <pre><code>python examples/gemini.py --yolo                # auto-approve permission prompts\npython examples/gemini.py --sandbox --model gemini-1.5-pro\n</code></pre> <p>Environment helpers:</p> <ul> <li><code>ACP_GEMINI_BIN</code> \u2014 override the CLI path (defaults to <code>PATH</code> lookup)</li> <li><code>ACP_GEMINI_TEST_ARGS</code> \u2014 extra flags forwarded during the smoke test</li> <li><code>ACP_ENABLE_GEMINI_TESTS=1</code> \u2014 opt-in toggle for <code>tests/test_gemini_example.py</code></li> </ul> <p>Authentication hiccups (e.g. missing <code>GOOGLE_CLOUD_PROJECT</code>) are surfaced but treated as skips during testing so the suite stays green on machines without credentials.</p>"},{"location":"quickstart/#next-steps","title":"Next steps","text":"<ul> <li>Compare what you built with the real integrations listed on the Use Cases page.</li> <li>Explore <code>docs/contrib.md</code> for higher-level utilities like session accumulators and permission brokers.</li> <li>Run <code>make check</code> / <code>make test</code> before committing changes, and regenerate schema artifacts with <code>make gen-all</code> when ACP versions advance.</li> <li>Need help? Start a thread in GitHub Discussions or chat with other ACP developers at agentclientprotocol.zulipchat.com.</li> </ul>"},{"location":"releasing/","title":"Releasing","text":"<p>Every package release tracks an upstream ACP schema tag from <code>agentclientprotocol/agent-client-protocol</code>. Follow this checklist to stay in lockstep.</p>"},{"location":"releasing/#prep-checklist","title":"Prep checklist","text":"<ol> <li>Choose the schema tag (e.g. <code>v0.4.5</code>) and regenerate artifacts:    <code>bash    ACP_SCHEMA_VERSION=v0.4.5 make gen-all</code>    This refreshes <code>schema/</code> and the generated <code>src/acp/schema.py</code>.</li> <li>Bump the SDK version in <code>pyproject.toml</code> (and regenerate <code>uv.lock</code> if deps moved).</li> <li>Run the standard gates: <code>bash    make check   # Ruff format/lint, type analysis, dep hygiene    make test    # pytest + doctests</code></li> <li>Refresh docs + examples so user-facing flows (e.g. Gemini bridge) reflect behaviour in the new schema.</li> </ol>"},{"location":"releasing/#commit-review","title":"Commit &amp; review","text":"<ul> <li>Keep the diff tight: regenerated schema files, version bumps, doc updates, and any required fixture refresh (goldens, RPC tests, etc.).</li> <li>Use a Conventional Commit such as <code>release: v0.4.5</code>.</li> <li>In the PR description, capture:</li> <li>The ACP schema tag you targeted.</li> <li>Output from <code>make check</code> / <code>make test</code> (and optional Gemini tests if you ran them).</li> <li>Behavioural or API highlights that reviewers should focus on.</li> </ul>"},{"location":"releasing/#publish-via-github-release","title":"Publish via GitHub Release","text":"<p>Releases are automated by <code>on-release-main.yml</code> once the PR lands on <code>main</code>.</p> <ol> <li>Draft a GitHub Release for the new tag (the UI creates the tag if missing).</li> <li>Publishing the release triggers the workflow, which:</li> <li>Syncs the tag back into <code>pyproject.toml</code>.</li> <li>Builds and uploads to PyPI via <code>uv publish</code> using <code>PYPI_TOKEN</code>.</li> <li>Deploys updated docs with <code>mkdocs gh-deploy</code>.</li> </ol> <p>No local build/publish steps are needed\u2014just provide a clear release summary (highlights, compatibility notes, migration tips).</p>"},{"location":"releasing/#extra-tips","title":"Extra tips","text":"<ul> <li>Breaking schema bumps often mean updating <code>tests/test_golden.py</code>, <code>tests/test_rpc.py</code>, and any examples touched by new fields.</li> <li>Use <code>make clean</code> if you need a fresh slate before re-running <code>make gen-all</code>.</li> <li>When available, run the Gemini smoke test (<code>ACP_ENABLE_GEMINI_TESTS=1</code>, set <code>ACP_GEMINI_BIN</code>) to catch regressions early.</li> </ul>"},{"location":"use-cases/","title":"Use Cases","text":"<p>This page mirrors the quick-read style of the README/index: skim the tables, copy links, and see how others apply the SDK. For the protocol overview itself, visit the official agent and client guides.</p>"},{"location":"use-cases/#agents","title":"Agents","text":"Project What it showcases MoonshotAI/kimi-cli A CLI-first ACP+MCP agent that helps with software dev and terminal workflows. Highlights streaming updates, permission prompts, and tool call UX."},{"location":"use-cases/#clients","title":"Clients","text":"Project What it showcases jimwhite/agent-client-kernel A Jupyter kernel that speaks ACP so notebooks can chat with external agents. Great reference if you\u2019re embedding ACP in notebook tooling. OhadRubin/simple-acp-client A Claude Agent SDK\u2013style Python client that wraps ACP executables with a friendly API. Use it as a starting point for bespoke clients."},{"location":"use-cases/#add-your-integration","title":"Add your integration","text":"<p>Shipping something with this SDK? Tell us!</p> <ul> <li>Open an issue or PR with a short blurb and link.</li> <li>Start a thread in GitHub Discussions.</li> <li>Drop a note in agentclientprotocol.zulipchat.com.</li> </ul> <p>We\u2019ll keep this list current so newcomers can see what\u2019s possible.</p>"}]}